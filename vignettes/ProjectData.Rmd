---
title: "How to use UMAP transform on a single cell dataset (Seurat) using iterative Latent Semantic Indexing"
output: html_document
date: "2024-09-23"
always_allow_html: true
editor_options: 
  chunk_output_type: console
---

Note that this code was inspired by and adapted from: 

ArchR: An integrative and scalable software package for single-cell chromatin accessibility analysis
#' Jeffrey M. Granja, M. Ryan Corces, Sarah E. Pierce, S. Tansu Bagdatli, Hani Choudhry, Howard Y. Chang, William J. Greenleaf
#' doi: https://doi.org/10.1101/2020.04.28.066498



```{r, echo=FALSE, results='hide', message=FALSE, warning=FALSE}
rm(list=ls())
# Define dataset paths depending on your machine
if(grepl("^gizmo", Sys.info()["nodename"])){
  ROOT_DIR1<-"/fh/fast/furlan_s/experiments/MB_10X_5p/cds"
  ROOT_DIR2<-"/fh/fast/furlan_s/grp/data/ddata/BM_data"
  ROOT_DIR3<-"/fh/fast/furlan_s/experiments/LRPBMC/cds"
} else {
  ROOT_DIR1<-"/Users/sfurlan/Library/CloudStorage/OneDrive-SharedLibraries-FredHutchinsonCancerCenter/Furlan_Lab - General/experiments/MB_10X_5p/cds"
  ROOT_DIR2<-"/Users/sfurlan/Library/CloudStorage/OneDrive-SharedLibraries-FredHutchinsonCancerCenter/Furlan_Lab - General/datasets/Healthy_BM_greenleaf"
  ROOT_DIR3<-"/Users/sfurlan/Library/CloudStorage/OneDrive-SharedLibraries-FredHutchinsonCancerCenter/Furlan_Lab - General/experiments/LRPBMC/cds"
}
```

## **Installing flscuts**

First, ensure you have the `devtools` R package installed, which allows you to install packages from GitHub. If `devtools` is installed, you can easily install using the following command:

```{r, eval=F}
devtools::install_github("furlan-lab/flscuts")
```

## **Loading data**

In this section, weâ€™ll load two Seurat objects, fix the celltypes so they harmonize, and create some colors.

```{r}
# Load required packages
suppressPackageStartupMessages({
  library(flscuts)
    library(Seurat)
  library(monocle3)
  library(viewmastR)
  library(ggplot2)
  library(magrittr)
  library(scCustomize)
})

# Load reference (seur) dataset
seur <- readRDS(file.path(ROOT_DIR1, "240813_final_object.RDS"))
DimPlot(seur, group.by = "celltype")
#Fix Tregs
FeaturePlot_scCustom(seur, features = "FOXP3")
seur$celltype[seur$seurat_clusters %in% "9"]<-"Treg"
DimPlot(seur, group.by = "celltype")

# Load query (seu) dataset
seu <-readRDS(file.path(ROOT_DIR3, "240919_5p_seu.RDS"))
DimPlot(seu, group.by = "mCelltype")
#Remove RBCs (as there aren't any in the ref)
seu <- seu[,!seu$mCelltype %in% "RBC"]
DimPlot(seu, group.by = "mCelltype")

# check that labels match
all(unique(seur$celltype) %in% unique(seu$mCelltype)) & all(unique(seu$mCelltype) %in% unique(seur$celltype))

# make some colors

cols1 <- as.character(pals::polychrome()[c(1,3:20)])
cols2 <- c("grey90", cols1)
```

## **Find shared features**

In this section we identify similarly variant genes that are common across the two datasets

```{r}
# Calculate and plot gene dispersion in query dataset
seu <- calculate_gene_dispersion(seu)
seu <- select_genes(seu, top_n = 10000, logmean_ul = -1, logmean_ll = -8)
plot_gene_dispersion(seu)
vgq <- get_selected_genes(seu)

# Repeat the process for the reference dataset
seur <- calculate_gene_dispersion(seur)
seur <- select_genes(seur, top_n = 10000, logmean_ul = -1, logmean_ll = -8)
plot_gene_dispersion(seur)
vgr <- get_selected_genes(seur)

# Find common genes
vg <- intersect(vgq, vgr)
```

## **Iterative Latent Sematic Indexing**

The overall goal is to use "iterative" (only 1 iteration) LSI with the same feature set on both datasets to create a reduction that can be used with umap transform

First, we run iterative LSI on the reference. We use an arbitrary number of LSI components and the common variant features found above.  Setting run_umap to true will enable this function to run, saving the UMAP model to the object.

```{r}
#iterative LSI
comps <- 25 #Number of PCs for clustering
seur<-iterative_LSI(seur, num_dim = comps, num_features = length(vg), resolution = c(1e-3), verbose = T, starting_features = vg, run_umap = T)

```


The UMAP performed on LSI looks like this.  Which is reasonable

```{r}
p1 <- DimPlot(seur, group.by = "celltype", cols = cols1)+theme_void()
p1
```


Next we take the "projectee", (aka the query data we want to project) and the "projector" aka referernce and run the following function which creates an output containing the coordinates for how the .


```{r}

res <- project_data(projector = seur, projectee = seu, reduced_dim = "lsi", embedding = "umap")

```




```{r}
p2 <- plot_projection(res, seur, seu, projectee_col = "mCelltype")+scale_color_manual(values = cols2)+theme_void()+ guides(color = guide_legend(override.aes = list(size = 3)))
p2

```

Side by side

```{r, fig.width=12}
cowplot::plot_grid(p1, p2)

```


## **Appendix**

```{r}
sessionInfo()
getwd()
```
